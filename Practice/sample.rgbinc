include "utils.rgbinc"

section "vblank_interrupt", rom0[$0040] ; vblank interrupt function call should be at this index
    reti ; not ret because wjenever the halt occurs the interrupts are disabled again, to not interrupt the interupt function call


def TILES_COUNT   equ (384)
def BYTES_PER_TILES   equ (16)
def TILES_BYTES_SIZE   equ (TILES_COUNT * BYTES_PER_TILES)

def TILEMAPS_COUNT     equ (2)
def BYTES_PER_TILEMAP   equ (1024)
def TILEMAP_BYTES_SIZE equ(TILEMAPS_COUNT * BYTES_PER_TILEMAP)

def GRAPHIC_DATA_SIZE   equ (TILEMAP_BYTES_SIZE + TILES_BYTES_SIZE)
def GRAPHIC_DATA_ADDRESS_END   equ ($8000)
def GRAPHIC_DATA_ADDRESS_START   equ (GRAPHIC_DATA_ADDRESS_END - GRAPHIC_DATA_SIZE)



macro InitOAM
    ld c, OAM_COUNT ; 40 sprites
    ld hl, _OAMRAM+OAMA_Y ; points to the first y address to the sprite
    ld de, sizeof_OAM_ATTRS ; 4 bytes
    .init_oam\@
        ld [hl], 0 ; set the Y to zero
        add hl, de ; jump to the next sprite
        dec c ; loop until the c , total number of sprites are zero
        jr nz, .init_oam\@
endm

macro LoadGraphicsDataIntoVRAM
    ld de, GRAPHIC_DATA_ADDRESS_START
    ld hl, _VRAM8000
    .load_title\@
        ld a, [de]
        inc de
        ld [hli], a
        ld a, d
        cp a, high(GRAPHIC_DATA_ADDRESS_END)
        jr nz, .load_title\@
endm

section "sample", rom0

InitSample:
    ; init the paletter for the background for the dmg
    ld a, %11100100 ; black-dargray-lightgray-white
    ld [rBGP], a
    ld [rOBP0], a
    ld a, %00011011
    ld [rOBP1], a

    InitOAM
    LoadGraphicsDataIntoVRAM

    ; enable the vlank interrupt
    ld a, IEF_VBLANK
    ld [rIE], a ; interrupt register only the vblank interupt
    ei ; enable interrupts

    ;place the window at the bottom of the screen
    ld a, 7 ;x coordinate starts at 7 instead of 0
    ld [rWX], a
    ld a, 120
    ld [rWY], a

    ;set the graphics paramters for the lcd to display the background and turn the LCD on
    ld a, LCDCF_ON | LCDCF_WINON | LCDCF_WIN9C00 | \
          LCDCF_BG8800 | LCDCF_OBJ16 | LCDCF_OBJON | LCDCF_BG9800 | LCDCF_BGON ; turn the lcd on - addressing mode - tilemap location - turn the bg on; for the windows turn it on and point to the second tilemap
    ld [rLCDC], a

    ret

UpdateSample:
    halt  ;enters the low power mode, suspends the CPU ins, then works on the interrupts that are enabled


    xor a
    ld [rSCX], a
    ld [rSCY], a

def SPRITE_ADDRESS_0 equ(_OAMRAM)
   copy [SPRITE_ADDRESS_0 + OAMA_X], 16
   copy [SPRITE_ADDRESS_0 + OAMA_Y], 32
   copy [SPRITE_ADDRESS_0 + OAMA_TILEID], 16
   copy [SPRITE_ADDRESS_0 + OAMA_FLAGS], OAMF_PAL0

def SPRITE_ADDRESS_1 equ(_OAMRAM + sizeof_OAM_ATTRS)
   copy [SPRITE_ADDRESS_1 + OAMA_X], 80
   copy [SPRITE_ADDRESS_1 + OAMA_Y], 80
   copy [SPRITE_ADDRESS_1 + OAMA_TILEID], 0
   copy [SPRITE_ADDRESS_1 + OAMA_FLAGS], OAMF_PAL0 | OAMF_XFLIP
    ret

export InitSample, UpdateSample


section "graphics_data", rom0[GRAPHIC_DATA_ADDRESS_START]
incbin "tileset.chr"
incbin "background.tlm"
incbin "window.tlm"
