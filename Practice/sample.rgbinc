include "utils.rgbinc"

section "vblank_interrupt", rom0[$0040] ; vblank interrupt function call should be at this index
    reti ; not ret because wjenever the halt occurs the interrupts are disabled again, to not interrupt the interupt function call


def TILES_COUNT   equ (384)
def BYTES_PER_TILES   equ (16)
def TILES_BYTES_SIZE   equ (TILES_COUNT * BYTES_PER_TILES)

def TILEMAPS_COUNT     equ (2)
def BYTES_PER_TILEMAP   equ (1024)
def TILEMAP_BYTES_SIZE equ(TILEMAPS_COUNT * BYTES_PER_TILEMAP)

def GRAPHIC_DATA_SIZE   equ (TILEMAP_BYTES_SIZE + TILES_BYTES_SIZE)
def GRAPHIC_DATA_ADDRESS_END   equ ($8000)
def GRAPHIC_DATA_ADDRESS_START   equ (GRAPHIC_DATA_ADDRESS_END - GRAPHIC_DATA_SIZE)


macro InitOAM
    ld c, OAM_COUNT ; 40 sprites
    ld hl, _OAMRAM+OAMA_Y ; points to the first y address to the sprite
    ld de, sizeof_OAM_ATTRS ; 4 bytes
    .init_oam\@
        ld [hl], 0 ; set the Y to zero
        add hl, de ; jump to the next sprite
        dec c ; loop until the c , total number of sprites are zero
        jr nz, .init_oam\@
endm

macro LoadGraphicsDataIntoVRAM
    ld de, GRAPHIC_DATA_ADDRESS_START
    ld hl, _VRAM8000
    .load_title\@
        ld a, [de]
        inc de
        ld [hli], a
        ld a, d
        cp a, high(GRAPHIC_DATA_ADDRESS_END)
        jr nz, .load_title\@
endm

rsset _RAM
def WRAM_PAD_INPUT rb sizeof_PAD_INPUT

def WRAM_BG_SCX rb 1
def WRAM_BG_SCY rb 1

def WRAM_WIN_ENABLE_FLAG rb 1

def WRAM_END rb 0

def WRAM_USAGE equ(WRAM_END - _RAM)
println "WRAM usage : {d:WRAM_USAGE} bytes"
assert WRAM_USAGE <= $2000, "Too many bytes used in WRAM"


section "sample", rom0

InitSample:
    ;init the WRAM state
    InitPadInput WRAM_PAD_INPUT
    xor a
    ld [WRAM_BG_SCX], a
    ld [WRAM_BG_SCY], a
    ld [WRAM_WIN_ENABLE_FLAG], a

    ; init the paletter for the background for the dmg
    ld a, %11100100 ; black-dargray-lightgray-white
    ld [rBGP], a
    ld [rOBP0], a
    ld a, %00011011
    ld [rOBP1], a

    InitOAM
    LoadGraphicsDataIntoVRAM

    ; enable the vlank interrupt
    ld a, IEF_VBLANK
    ld [rIE], a ; interrupt register only the vblank interupt
    ei ; enable interrupts

    ;place the window at the bottom of the screen
    ld a, 7 ;x coordinate starts at 7 instead of 0
    ld [rWX], a
    ld a, 120
    ld [rWY], a

    ;set the graphics paramters for the lcd to display the background and turn the LCD on
    ld a, LCDCF_ON | LCDCF_WINON | LCDCF_WIN9C00 | \
          LCDCF_BG8800 | LCDCF_OBJ16 | LCDCF_OBJON | LCDCF_BG9800 | LCDCF_BGON ; turn the lcd on - addressing mode - tilemap location - turn the bg on; for the windows turn it on and point to the second tilemap
    ld [rLCDC], a

    ret

UpdateSample:
    halt  ;enters the low power mode, suspends the CPU ins, then works on the interrupts that are enabled

    ; set the bg position
    copy [rSCX], [WRAM_BG_SCX]
    copy [rSCY], [WRAM_BG_SCY]

    ; toggle thw window on or off
    ldh a, [rLCDC]
    and a, ~LCDCF_WINON
    ld hl, WRAM_WIN_ENABLE_FLAG
    or a, [hl]
    ldh [rLCDC], a

    ;logic for the input  update

    UpdatePadInput WRAM_PAD_INPUT

    ; d pad check
    TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_LEFT
    jr nz, .left_checked
        ld hl, WRAM_BG_SCX
        dec [hl]
    .left_checked
    TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_RIGHT
    jr nz, .right_checked
        ld hl, WRAM_BG_SCX
        inc [hl]
    .right_checked
    TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_UP
    jr nz, .up_checked
        ld hl, WRAM_BG_SCY
        dec [hl]
    .up_checked
    TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_DOWN
    jr nz, .down_checked
        ld hl, WRAM_BG_SCY
        inc [hl]
    .down_checked
    TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_A
    jr nz, .window_toggle_done
        ld a, [WRAM_WIN_ENABLE_FLAG]
        cpl
        and a, LCDCF_WINON
        ld [WRAM_WIN_ENABLE_FLAG], a
    .window_toggle_done

def SPRITE_ADDRESS_0 equ(_OAMRAM)
   copy [SPRITE_ADDRESS_0 + OAMA_X], 16
   copy [SPRITE_ADDRESS_0 + OAMA_Y], 32
   copy [SPRITE_ADDRESS_0 + OAMA_TILEID], 16
   copy [SPRITE_ADDRESS_0 + OAMA_FLAGS], OAMF_PAL0

def SPRITE_ADDRESS_1 equ(_OAMRAM + sizeof_OAM_ATTRS)
   copy [SPRITE_ADDRESS_1 + OAMA_X], 80
   copy [SPRITE_ADDRESS_1 + OAMA_Y], 80
   copy [SPRITE_ADDRESS_1 + OAMA_TILEID], 0
   copy [SPRITE_ADDRESS_1 + OAMA_FLAGS], OAMF_PAL0 | OAMF_XFLIP
    ret

export InitSample, UpdateSample


section "graphics_data", rom0[GRAPHIC_DATA_ADDRESS_START]
incbin "tileset.chr"
incbin "background.tlm"
incbin "window.tlm"
